<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>JDFTx: core/BlasExtra.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="jdftx-55.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">JDFTx
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('BlasExtra_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">BlasExtra.h File Reference<div class="ingroups"><a class="el" href="group__Operators.html">Operator implementations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Commonly used BLAS-like routines.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;gsl/gsl_cblas.h&gt;</code><br/>
<code>#include &lt;cstdlib&gt;</code><br/>
<code>#include &lt;cstdio&gt;</code><br/>
<code>#include &lt;cfloat&gt;</code><br/>
<code>#include &lt;<a class="el" href="scalar_8h.html">core/scalar.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="Thread_8h.html">core/Thread.h</a>&gt;</code><br/>
<code>#include &lt;cublas.h&gt;</code><br/>
<code>#include &lt;cuda_runtime.h&gt;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1d6b0e34680298982988b556e5ae0312"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1d6b0e34680298982988b556e5ae0312"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga1d6b0e34680298982988b556e5ae0312">eblas_dscal_gpu</a>&#160;&#160;&#160;cublasDscal</td></tr>
<tr class="memdesc:ga1d6b0e34680298982988b556e5ae0312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gaaf6bba434761869bd04fbd191859cc67" title="Scale a real array: threaded wrapper to the cblas_dscal BLAS1 function. ">eblas_dscal()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga1d6b0e34680298982988b556e5ae0312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23a5c5c58dd853cf7a55f972bfdc9312"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga23a5c5c58dd853cf7a55f972bfdc9312"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga23a5c5c58dd853cf7a55f972bfdc9312">eblas_daxpy_gpu</a>&#160;&#160;&#160;cublasDaxpy</td></tr>
<tr class="memdesc:ga23a5c5c58dd853cf7a55f972bfdc9312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gaad007d0c4eb9fe5c141f9d48bb0dd710" title="Scaled-accumulate on real arrays: threaded wrapper to the cblas_daxpy BLAS1 function. ">eblas_daxpy()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga23a5c5c58dd853cf7a55f972bfdc9312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed560fa37afc8e9efabedada3f0601a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6ed560fa37afc8e9efabedada3f0601a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6ed560fa37afc8e9efabedada3f0601a">eblas_ddot_gpu</a>&#160;&#160;&#160;cublasDdot</td></tr>
<tr class="memdesc:ga6ed560fa37afc8e9efabedada3f0601a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gaffe4a0ee242ac993d41a38f9914dc583" title="Dot product of real arrays: threaded wrapper to the cblas_ddot BLAS1 function. ">eblas_ddot()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga6ed560fa37afc8e9efabedada3f0601a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f380d51545423df4bea1606872b25f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f380d51545423df4bea1606872b25f5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6f380d51545423df4bea1606872b25f5">eblas_dnrm2_gpu</a>&#160;&#160;&#160;cublasDnrm2</td></tr>
<tr class="memdesc:ga6f380d51545423df4bea1606872b25f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga465cc13a28dd1b92df1929e386516b3e" title="2-norm of a real array: threaded wrapper to the cblas_dnrm2 BLAS1 function ">eblas_dnrm2()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga6f380d51545423df4bea1606872b25f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60f1cf2483a1cf0031f237bb3e50c299"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga60f1cf2483a1cf0031f237bb3e50c299"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga60f1cf2483a1cf0031f237bb3e50c299">callPref</a>(functionName)&#160;&#160;&#160;functionName##_gpu</td></tr>
<tr class="memdesc:ga60f1cf2483a1cf0031f237bb3e50c299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select between functionName and functionName_gpu for the CPU and GPU executables respectively. <br/></td></tr>
<tr class="separator:ga60f1cf2483a1cf0031f237bb3e50c299"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga16b2911192a4dd45990e8d3c8749bc3c"><td class="memTemplParams" colspan="2">template&lt;typename Ty , typename Tx &gt; </td></tr>
<tr class="memitem:ga16b2911192a4dd45990e8d3c8749bc3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga16b2911192a4dd45990e8d3c8749bc3c">eblas_mul</a> (const int N, const Tx *X, const int incX, Ty *Y, const int incY)</td></tr>
<tr class="memdesc:ga16b2911192a4dd45990e8d3c8749bc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated elementwise multiply Y *= X for arrays X, Y.  <a href="group__Operators.html#ga16b2911192a4dd45990e8d3c8749bc3c">More...</a><br/></td></tr>
<tr class="separator:ga16b2911192a4dd45990e8d3c8749bc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6379a3d39a315ffa2dcf2c92477741b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6379a3d39a315ffa2dcf2c92477741b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6379a3d39a315ffa2dcf2c92477741b1">eblas_dmul</a> (const int N, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="memdesc:ga6379a3d39a315ffa2dcf2c92477741b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga16b2911192a4dd45990e8d3c8749bc3c" title="Templated elementwise multiply Y *= X for arrays X, Y. ">eblas_mul()</a> for double[] *= double[]. <br/></td></tr>
<tr class="separator:ga6379a3d39a315ffa2dcf2c92477741b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e0b6dcdf4b62d7e67e7317502673c20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6e0b6dcdf4b62d7e67e7317502673c20"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6e0b6dcdf4b62d7e67e7317502673c20">eblas_zmul</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga6e0b6dcdf4b62d7e67e7317502673c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga16b2911192a4dd45990e8d3c8749bc3c" title="Templated elementwise multiply Y *= X for arrays X, Y. ">eblas_mul()</a> for complex[] *= complex[]. <br/></td></tr>
<tr class="separator:ga6e0b6dcdf4b62d7e67e7317502673c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2140c951abf8544320da930a0ebd4548"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2140c951abf8544320da930a0ebd4548"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga2140c951abf8544320da930a0ebd4548">eblas_zmuld</a> (const int N, const double *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga2140c951abf8544320da930a0ebd4548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga16b2911192a4dd45990e8d3c8749bc3c" title="Templated elementwise multiply Y *= X for arrays X, Y. ">eblas_mul()</a> for complex[] *= double[]. <br/></td></tr>
<tr class="separator:ga2140c951abf8544320da930a0ebd4548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee5e834dbcc79293125ffb0aa1b54a5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee5e834dbcc79293125ffb0aa1b54a5e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaee5e834dbcc79293125ffb0aa1b54a5e">eblas_dmul_gpu</a> (const int N, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="memdesc:gaee5e834dbcc79293125ffb0aa1b54a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6379a3d39a315ffa2dcf2c92477741b1" title="Specialization of eblas_mul() for double[] *= double[]. ">eblas_dmul()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:gaee5e834dbcc79293125ffb0aa1b54a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ef44b279657aad37389393e3f03ed6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3ef44b279657aad37389393e3f03ed6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga3ef44b279657aad37389393e3f03ed6d">eblas_zmul_gpu</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga3ef44b279657aad37389393e3f03ed6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6e0b6dcdf4b62d7e67e7317502673c20" title="Specialization of eblas_mul() for complex[] *= complex[]. ">eblas_zmul()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga3ef44b279657aad37389393e3f03ed6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc467ff9f0a44f8eace7f68d5391ccc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabc467ff9f0a44f8eace7f68d5391ccc8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gabc467ff9f0a44f8eace7f68d5391ccc8">eblas_zmuld_gpu</a> (const int N, const double *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:gabc467ff9f0a44f8eace7f68d5391ccc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga2140c951abf8544320da930a0ebd4548" title="Specialization of eblas_mul() for complex[] *= double[]. ">eblas_zmuld()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:gabc467ff9f0a44f8eace7f68d5391ccc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7f3fb6cf181094d3969a28f2d661f1"><td class="memTemplParams" colspan="2">template&lt;typename Ty , typename Tx &gt; </td></tr>
<tr class="memitem:ga8d7f3fb6cf181094d3969a28f2d661f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8d7f3fb6cf181094d3969a28f2d661f1">eblas_div</a> (const int N, const Tx *X, const int incX, Ty *Y, const int incY)</td></tr>
<tr class="memdesc:ga8d7f3fb6cf181094d3969a28f2d661f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated elementwise divide Y /= X for arrays X, Y.  <a href="group__Operators.html#ga8d7f3fb6cf181094d3969a28f2d661f1">More...</a><br/></td></tr>
<tr class="separator:ga8d7f3fb6cf181094d3969a28f2d661f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab632432b443a6e1569bd0d35b2b9d875"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab632432b443a6e1569bd0d35b2b9d875"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gab632432b443a6e1569bd0d35b2b9d875">eblas_ddiv</a> (const int N, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="memdesc:gab632432b443a6e1569bd0d35b2b9d875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga8d7f3fb6cf181094d3969a28f2d661f1" title="Templated elementwise divide Y /= X for arrays X, Y. ">eblas_div()</a> for double[] /= double[]. <br/></td></tr>
<tr class="separator:gab632432b443a6e1569bd0d35b2b9d875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a317f91a1c555cc4e57686a68fce61a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a317f91a1c555cc4e57686a68fce61a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga5a317f91a1c555cc4e57686a68fce61a">eblas_zdiv</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga5a317f91a1c555cc4e57686a68fce61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga8d7f3fb6cf181094d3969a28f2d661f1" title="Templated elementwise divide Y /= X for arrays X, Y. ">eblas_div()</a> for <a class="el" href="structcomplex.html" title="Complex number (need to define our own because we need operators for gpu code as well) ...">complex</a>[] /= <a class="el" href="structcomplex.html" title="Complex number (need to define our own because we need operators for gpu code as well) ...">complex</a>[]. <br/></td></tr>
<tr class="separator:ga5a317f91a1c555cc4e57686a68fce61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d1d01b5955a584591c77bf491648d10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4d1d01b5955a584591c77bf491648d10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga4d1d01b5955a584591c77bf491648d10">eblas_zdivd</a> (const int N, const double *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga4d1d01b5955a584591c77bf491648d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="group__Operators.html#ga8d7f3fb6cf181094d3969a28f2d661f1" title="Templated elementwise divide Y /= X for arrays X, Y. ">eblas_div()</a> for <a class="el" href="structcomplex.html" title="Complex number (need to define our own because we need operators for gpu code as well) ...">complex</a>[] /= double[]. <br/></td></tr>
<tr class="separator:ga4d1d01b5955a584591c77bf491648d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b56254d2d085b314f397614431d9be8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b56254d2d085b314f397614431d9be8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6b56254d2d085b314f397614431d9be8">eblas_ddiv_gpu</a> (const int N, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="memdesc:ga6b56254d2d085b314f397614431d9be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gab632432b443a6e1569bd0d35b2b9d875" title="Specialization of eblas_div() for double[] /= double[]. ">eblas_ddiv()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga6b56254d2d085b314f397614431d9be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90dc7695ae5fa193758cf1dd1167cef2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga90dc7695ae5fa193758cf1dd1167cef2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga90dc7695ae5fa193758cf1dd1167cef2">eblas_zdiv_gpu</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga90dc7695ae5fa193758cf1dd1167cef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga5a317f91a1c555cc4e57686a68fce61a" title="Specialization of eblas_div() for complex[] /= complex[]. ">eblas_zdiv()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga90dc7695ae5fa193758cf1dd1167cef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38da349ef7eb56da44c850ce79513abd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga38da349ef7eb56da44c850ce79513abd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga38da349ef7eb56da44c850ce79513abd">eblas_zdivd_gpu</a> (const int N, const double *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:ga38da349ef7eb56da44c850ce79513abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga4d1d01b5955a584591c77bf491648d10" title="Specialization of eblas_div() for complex[] /= double[]. ">eblas_zdivd()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga38da349ef7eb56da44c850ce79513abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f427ab61421ff49e1a5e3f2e4bd5ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga77f427ab61421ff49e1a5e3f2e4bd5ab">eblas_lincomb</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> &amp;sX, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, const <a class="el" href="structcomplex.html">complex</a> &amp;sY, const <a class="el" href="structcomplex.html">complex</a> *Y, const int incY, <a class="el" href="structcomplex.html">complex</a> *Z, const int incZ)</td></tr>
<tr class="memdesc:ga77f427ab61421ff49e1a5e3f2e4bd5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise linear combination Z = sX * X + sY * Y.  <a href="group__Operators.html#ga77f427ab61421ff49e1a5e3f2e4bd5ab">More...</a><br/></td></tr>
<tr class="separator:ga77f427ab61421ff49e1a5e3f2e4bd5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d58c4fae414cd9011e7f50d8943b6fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8d58c4fae414cd9011e7f50d8943b6fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8d58c4fae414cd9011e7f50d8943b6fc">eblas_lincomb_gpu</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> &amp;sX, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, const <a class="el" href="structcomplex.html">complex</a> &amp;sY, const <a class="el" href="structcomplex.html">complex</a> *Y, const int incY, <a class="el" href="structcomplex.html">complex</a> *Z, const int incZ)</td></tr>
<tr class="memdesc:ga8d58c4fae414cd9011e7f50d8943b6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga77f427ab61421ff49e1a5e3f2e4bd5ab" title="Elementwise linear combination Z = sX * X + sY * Y. ">eblas_lincomb()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga8d58c4fae414cd9011e7f50d8943b6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd2a68d44d54ff9cc6547fcd15baf8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2bd2a68d44d54ff9cc6547fcd15baf8a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga2bd2a68d44d54ff9cc6547fcd15baf8a">eblas_zgemm</a> (CBLAS_TRANSPOSE TransA, CBLAS_TRANSPOSE TransB, int M, int N, int K, const <a class="el" href="structcomplex.html">complex</a> &amp;alpha, const <a class="el" href="structcomplex.html">complex</a> *A, const int lda, const <a class="el" href="structcomplex.html">complex</a> *B, const int ldb, const <a class="el" href="structcomplex.html">complex</a> &amp;beta, <a class="el" href="structcomplex.html">complex</a> *C, const int ldc)</td></tr>
<tr class="memdesc:ga2bd2a68d44d54ff9cc6547fcd15baf8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded complex matrix multiply (threaded wrapper around zgemm) All the parameters have the same meaning as in cblas_zgemm, except element order is always Column Major (FORTRAN order!) <br/></td></tr>
<tr class="separator:ga2bd2a68d44d54ff9cc6547fcd15baf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0586fe5f4eadb75205bad2eeaecd224c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0586fe5f4eadb75205bad2eeaecd224c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga0586fe5f4eadb75205bad2eeaecd224c">eblas_zgemm_gpu</a> (CBLAS_TRANSPOSE TransA, CBLAS_TRANSPOSE TransB, int M, int N, int K, const <a class="el" href="structcomplex.html">complex</a> &amp;alpha, const <a class="el" href="structcomplex.html">complex</a> *A, const int lda, const <a class="el" href="structcomplex.html">complex</a> *B, const int ldb, const <a class="el" href="structcomplex.html">complex</a> &amp;beta, <a class="el" href="structcomplex.html">complex</a> *C, const int ldc)</td></tr>
<tr class="memdesc:ga0586fe5f4eadb75205bad2eeaecd224c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap cublasZgemm to provide the same interface as <a class="el" href="group__Operators.html#ga2bd2a68d44d54ff9cc6547fcd15baf8a" title="Threaded complex matrix multiply (threaded wrapper around zgemm) All the parameters have the same mea...">eblas_zgemm()</a> <br/></td></tr>
<tr class="separator:ga0586fe5f4eadb75205bad2eeaecd224c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6920f2c3375ac67c6baf1af5c8043063"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063">eblas_scatter_zdaxpy</a> (const int Nindex, double a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga6920f2c3375ac67c6baf1af5c8043063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter y(index) += a * x.  <a href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063">More...</a><br/></td></tr>
<tr class="separator:ga6920f2c3375ac67c6baf1af5c8043063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8401f2eef0fc7b6b7aa22066a82bf3c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8401f2eef0fc7b6b7aa22066a82bf3c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8401f2eef0fc7b6b7aa22066a82bf3c1">eblas_scatter_zaxpy</a> (const int Nindex, <a class="el" href="structcomplex.html">complex</a> a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga8401f2eef0fc7b6b7aa22066a82bf3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063" title="Scatter y(index) += a * x. ">eblas_scatter_zdaxpy()</a> with a complex scale factor. <br/></td></tr>
<tr class="separator:ga8401f2eef0fc7b6b7aa22066a82bf3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2ba4babf1d2cbf1ab787c8c33c5ee91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad2ba4babf1d2cbf1ab787c8c33c5ee91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gad2ba4babf1d2cbf1ab787c8c33c5ee91">eblas_scatter_daxpy</a> (const int Nindex, double a, const int *index, const double *x, double *y, const double *w=0)</td></tr>
<tr class="memdesc:gad2ba4babf1d2cbf1ab787c8c33c5ee91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063" title="Scatter y(index) += a * x. ">eblas_scatter_zdaxpy()</a> for real data arrays. <br/></td></tr>
<tr class="separator:gad2ba4babf1d2cbf1ab787c8c33c5ee91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga749e567418ffb3a1c3b9de6774eeb493"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga749e567418ffb3a1c3b9de6774eeb493">eblas_gather_zdaxpy</a> (const int Nindex, double a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga749e567418ffb3a1c3b9de6774eeb493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather y += a * x(index)  <a href="group__Operators.html#ga749e567418ffb3a1c3b9de6774eeb493">More...</a><br/></td></tr>
<tr class="separator:ga749e567418ffb3a1c3b9de6774eeb493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a97b86d5b2ab21d4d1fb918f13f3cc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2a97b86d5b2ab21d4d1fb918f13f3cc9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga2a97b86d5b2ab21d4d1fb918f13f3cc9">eblas_gather_zaxpy</a> (const int Nindex, <a class="el" href="structcomplex.html">complex</a> a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga2a97b86d5b2ab21d4d1fb918f13f3cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga749e567418ffb3a1c3b9de6774eeb493" title="Gather y += a * x(index) ">eblas_gather_zdaxpy()</a> with a complex scale factor. <br/></td></tr>
<tr class="separator:ga2a97b86d5b2ab21d4d1fb918f13f3cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cbc123f1c40b70689d154c73817736a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3cbc123f1c40b70689d154c73817736a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga3cbc123f1c40b70689d154c73817736a">eblas_gather_daxpy</a> (const int Nindex, double a, const int *index, const double *x, double *y, const double *w=0)</td></tr>
<tr class="memdesc:ga3cbc123f1c40b70689d154c73817736a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063" title="Scatter y(index) += a * x. ">eblas_scatter_zdaxpy()</a> for real data arrays. <br/></td></tr>
<tr class="separator:ga3cbc123f1c40b70689d154c73817736a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd3623c1986cc3347b38d084d9a9e71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3dd3623c1986cc3347b38d084d9a9e71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga3dd3623c1986cc3347b38d084d9a9e71">eblas_scatter_zdaxpy_gpu</a> (const int Nindex, double a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga3dd3623c1986cc3347b38d084d9a9e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6920f2c3375ac67c6baf1af5c8043063" title="Scatter y(index) += a * x. ">eblas_scatter_zdaxpy()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga3dd3623c1986cc3347b38d084d9a9e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab777fea35e9b776432add8df3f2ff2f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab777fea35e9b776432add8df3f2ff2f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gab777fea35e9b776432add8df3f2ff2f7">eblas_scatter_zaxpy_gpu</a> (const int Nindex, <a class="el" href="structcomplex.html">complex</a> a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:gab777fea35e9b776432add8df3f2ff2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga8401f2eef0fc7b6b7aa22066a82bf3c1" title="Equivalent of eblas_scatter_zdaxpy() with a complex scale factor. ">eblas_scatter_zaxpy()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:gab777fea35e9b776432add8df3f2ff2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13b559e3aa3e1a00e892f19102140cbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga13b559e3aa3e1a00e892f19102140cbd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga13b559e3aa3e1a00e892f19102140cbd">eblas_scatter_daxpy_gpu</a> (const int Nindex, double a, const int *index, const double *x, double *y, const double *w=0)</td></tr>
<tr class="memdesc:ga13b559e3aa3e1a00e892f19102140cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gad2ba4babf1d2cbf1ab787c8c33c5ee91" title="Equivalent of eblas_scatter_zdaxpy() for real data arrays. ">eblas_scatter_daxpy()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga13b559e3aa3e1a00e892f19102140cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bcee46d09c50792e323bd2e6024d3a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5bcee46d09c50792e323bd2e6024d3a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga5bcee46d09c50792e323bd2e6024d3a5">eblas_gather_zdaxpy_gpu</a> (const int Nindex, double a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga5bcee46d09c50792e323bd2e6024d3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga749e567418ffb3a1c3b9de6774eeb493" title="Gather y += a * x(index) ">eblas_gather_zdaxpy()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga5bcee46d09c50792e323bd2e6024d3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga577e87716bb8bb527693f6a7832f2d7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga577e87716bb8bb527693f6a7832f2d7f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga577e87716bb8bb527693f6a7832f2d7f">eblas_gather_zaxpy_gpu</a> (const int Nindex, <a class="el" href="structcomplex.html">complex</a> a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjx=false, const <a class="el" href="structcomplex.html">complex</a> *w=0, bool conjw=false)</td></tr>
<tr class="memdesc:ga577e87716bb8bb527693f6a7832f2d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga2a97b86d5b2ab21d4d1fb918f13f3cc9" title="Equivalent of eblas_gather_zdaxpy() with a complex scale factor. ">eblas_gather_zaxpy()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga577e87716bb8bb527693f6a7832f2d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e81fcb0406e3cac6c632fe90f4740ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4e81fcb0406e3cac6c632fe90f4740ac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga4e81fcb0406e3cac6c632fe90f4740ac">eblas_gather_daxpy_gpu</a> (const int Nindex, double a, const int *index, const double *x, double *y, const double *w=0)</td></tr>
<tr class="memdesc:ga4e81fcb0406e3cac6c632fe90f4740ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga3cbc123f1c40b70689d154c73817736a" title="Equivalent of eblas_scatter_zdaxpy() for real data arrays. ">eblas_gather_daxpy()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga4e81fcb0406e3cac6c632fe90f4740ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c1b03241b133beaed04728d26a086e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga6c1b03241b133beaed04728d26a086e3">eblas_accumNorm</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *x, double *y)</td></tr>
<tr class="memdesc:ga6c1b03241b133beaed04728d26a086e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate elementwise norm of a complex array x into y i.e. y += a x conj(x)  <a href="group__Operators.html#ga6c1b03241b133beaed04728d26a086e3">More...</a><br/></td></tr>
<tr class="separator:ga6c1b03241b133beaed04728d26a086e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e140105e5e7ee1f8baaff4e6a016bf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga1e140105e5e7ee1f8baaff4e6a016bf5">eblas_accumProd</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *xU, const <a class="el" href="structcomplex.html">complex</a> *xC, double *yRe, double *yIm)</td></tr>
<tr class="memdesc:ga1e140105e5e7ee1f8baaff4e6a016bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate elementwise product of two complex arrays xU and xC into real and imaginary parts yRe and yIm i.e. (yRe + i yIm) += a xU conj(xC)  <a href="group__Operators.html#ga1e140105e5e7ee1f8baaff4e6a016bf5">More...</a><br/></td></tr>
<tr class="separator:ga1e140105e5e7ee1f8baaff4e6a016bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4990759337c29d9752c444b78e3930db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4990759337c29d9752c444b78e3930db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga4990759337c29d9752c444b78e3930db">eblas_accumNorm_gpu</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *x, double *y)</td></tr>
<tr class="memdesc:ga4990759337c29d9752c444b78e3930db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga6c1b03241b133beaed04728d26a086e3" title="Accumulate elementwise norm of a complex array x into y i.e. y += a x conj(x) ">eblas_accumNorm()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga4990759337c29d9752c444b78e3930db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25e99d5e1c919ea332e5232c4ddf7258"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga25e99d5e1c919ea332e5232c4ddf7258"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga25e99d5e1c919ea332e5232c4ddf7258">eblas_accumProd_gpu</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *xU, const <a class="el" href="structcomplex.html">complex</a> *xC, double *yRe, double *yIm)</td></tr>
<tr class="memdesc:ga25e99d5e1c919ea332e5232c4ddf7258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga1e140105e5e7ee1f8baaff4e6a016bf5" title="Accumulate elementwise product of two complex arrays xU and xC into real and imaginary parts yRe and ...">eblas_accumProd()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga25e99d5e1c919ea332e5232c4ddf7258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d2cefdcc0e49ab0781fab0609ef5d74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74">eblas_symmetrize</a> (int N, int n, const int *symmIndex, double *x)</td></tr>
<tr class="memdesc:ga9d2cefdcc0e49ab0781fab0609ef5d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrize an array x, using N n-fold equivalence classes in symmIndex.  <a href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74">More...</a><br/></td></tr>
<tr class="separator:ga9d2cefdcc0e49ab0781fab0609ef5d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c011b9e8e8f8086690068bcfa7ca92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa0c011b9e8e8f8086690068bcfa7ca92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaa0c011b9e8e8f8086690068bcfa7ca92">eblas_symmetrize</a> (int N, int n, const int *symmIndex, <a class="el" href="structcomplex.html">complex</a> *x)</td></tr>
<tr class="memdesc:gaa0c011b9e8e8f8086690068bcfa7ca92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74" title="Symmetrize an array x, using N n-fold equivalence classes in symmIndex. ">eblas_symmetrize()</a> for complex data pointers. <br/></td></tr>
<tr class="separator:gaa0c011b9e8e8f8086690068bcfa7ca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae81ee89ce9455db6d3a33ed7d85dea5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaae81ee89ce9455db6d3a33ed7d85dea5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaae81ee89ce9455db6d3a33ed7d85dea5">eblas_symmetrize_gpu</a> (int N, int n, const int *symmIndex, double *x)</td></tr>
<tr class="memdesc:gaae81ee89ce9455db6d3a33ed7d85dea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74" title="Symmetrize an array x, using N n-fold equivalence classes in symmIndex. ">eblas_symmetrize()</a> for real GPU data pointers. <br/></td></tr>
<tr class="separator:gaae81ee89ce9455db6d3a33ed7d85dea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a72763dcf3012ff1978f77c9f569ce8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a72763dcf3012ff1978f77c9f569ce8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga5a72763dcf3012ff1978f77c9f569ce8">eblas_symmetrize_gpu</a> (int N, int n, const int *symmIndex, <a class="el" href="structcomplex.html">complex</a> *x)</td></tr>
<tr class="memdesc:ga5a72763dcf3012ff1978f77c9f569ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74" title="Symmetrize an array x, using N n-fold equivalence classes in symmIndex. ">eblas_symmetrize()</a> for complex GPU data pointers. <br/></td></tr>
<tr class="separator:ga5a72763dcf3012ff1978f77c9f569ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae73590ae7d8bc5430e35a0eca6590b09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gae73590ae7d8bc5430e35a0eca6590b09">eblas_symmetrize</a> (int N, int n, const int *symmIndex, const int *symmMult, const <a class="el" href="structcomplex.html">complex</a> *phase, <a class="el" href="structcomplex.html">complex</a> *x)</td></tr>
<tr class="memdesc:gae73590ae7d8bc5430e35a0eca6590b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrize a complex array x with phase factors, using N n-fold equivalence classes in symmIndex (useful for space group symmetrization in reciprocal space)  <a href="group__Operators.html#gae73590ae7d8bc5430e35a0eca6590b09">More...</a><br/></td></tr>
<tr class="separator:gae73590ae7d8bc5430e35a0eca6590b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a426fdd52157c7d1a984f5d2c4876c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8a426fdd52157c7d1a984f5d2c4876c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8a426fdd52157c7d1a984f5d2c4876c8">eblas_symmetrize_gpu</a> (int N, int n, const int *symmIndex, const int *symmMult, const <a class="el" href="structcomplex.html">complex</a> *phase, <a class="el" href="structcomplex.html">complex</a> *x)</td></tr>
<tr class="memdesc:ga8a426fdd52157c7d1a984f5d2c4876c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga9d2cefdcc0e49ab0781fab0609ef5d74" title="Symmetrize an array x, using N n-fold equivalence classes in symmIndex. ">eblas_symmetrize()</a> for complex GPU data pointers. <br/></td></tr>
<tr class="separator:ga8a426fdd52157c7d1a984f5d2c4876c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e6f244886dd30b195522884c18637f2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3e6f244886dd30b195522884c18637f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga3e6f244886dd30b195522884c18637f2">eblas_copy</a> (T *dest, const T *src, int N)</td></tr>
<tr class="memdesc:ga3e6f244886dd30b195522884c18637f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a data array.  <a href="group__Operators.html#ga3e6f244886dd30b195522884c18637f2">More...</a><br/></td></tr>
<tr class="separator:ga3e6f244886dd30b195522884c18637f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86241e74ed835c20636e5f67b22abf3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga86241e74ed835c20636e5f67b22abf3b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga86241e74ed835c20636e5f67b22abf3b">eblas_zero</a> (int N, T *x)</td></tr>
<tr class="memdesc:ga86241e74ed835c20636e5f67b22abf3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero a data array.  <a href="group__Operators.html#ga86241e74ed835c20636e5f67b22abf3b">More...</a><br/></td></tr>
<tr class="separator:ga86241e74ed835c20636e5f67b22abf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf6bba434761869bd04fbd191859cc67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaf6bba434761869bd04fbd191859cc67"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaaf6bba434761869bd04fbd191859cc67">eblas_dscal</a> (int N, double a, double *x, int incx)</td></tr>
<tr class="memdesc:gaaf6bba434761869bd04fbd191859cc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a real array: threaded wrapper to the cblas_dscal BLAS1 function. <br/></td></tr>
<tr class="separator:gaaf6bba434761869bd04fbd191859cc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7106ac749d4593f73b27a119e9486e6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7106ac749d4593f73b27a119e9486e6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga7106ac749d4593f73b27a119e9486e6d">eblas_zdscal</a> (int N, double a, <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:ga7106ac749d4593f73b27a119e9486e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a complex array by a real scale factor: threaded wrapper to the cblas_zdscal BLAS1 function. <br/></td></tr>
<tr class="separator:ga7106ac749d4593f73b27a119e9486e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7511a88828ad90e98f9e7995813b49be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7511a88828ad90e98f9e7995813b49be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga7511a88828ad90e98f9e7995813b49be">eblas_zscal</a> (int N, const <a class="el" href="structcomplex.html">complex</a> &amp;a, <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:ga7511a88828ad90e98f9e7995813b49be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a complex array by a complex scale factor: threaded wrapper to the cblas_zscal BLAS1 function. <br/></td></tr>
<tr class="separator:ga7511a88828ad90e98f9e7995813b49be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad007d0c4eb9fe5c141f9d48bb0dd710"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaad007d0c4eb9fe5c141f9d48bb0dd710"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaad007d0c4eb9fe5c141f9d48bb0dd710">eblas_daxpy</a> (int N, double a, const double *x, int incx, double *y, int incy)</td></tr>
<tr class="memdesc:gaad007d0c4eb9fe5c141f9d48bb0dd710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaled-accumulate on real arrays: threaded wrapper to the cblas_daxpy BLAS1 function. <br/></td></tr>
<tr class="separator:gaad007d0c4eb9fe5c141f9d48bb0dd710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87bedbfedbae0efdb4b4c1207e36783d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga87bedbfedbae0efdb4b4c1207e36783d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga87bedbfedbae0efdb4b4c1207e36783d">eblas_zaxpy</a> (int N, const <a class="el" href="structcomplex.html">complex</a> &amp;a, const <a class="el" href="structcomplex.html">complex</a> *x, int incx, <a class="el" href="structcomplex.html">complex</a> *y, int incy)</td></tr>
<tr class="memdesc:ga87bedbfedbae0efdb4b4c1207e36783d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaled-accumulate on complex arrays: threaded wrapper to the cblas_zaxpy BLAS1 function. <br/></td></tr>
<tr class="separator:ga87bedbfedbae0efdb4b4c1207e36783d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafafc5a6d2f24e055d3b9d4e36198f706"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafafc5a6d2f24e055d3b9d4e36198f706"></a>
<a class="el" href="structcomplex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gafafc5a6d2f24e055d3b9d4e36198f706">eblas_zdotc</a> (int N, const <a class="el" href="structcomplex.html">complex</a> *x, int incx, const <a class="el" href="structcomplex.html">complex</a> *y, int incy)</td></tr>
<tr class="memdesc:gafafc5a6d2f24e055d3b9d4e36198f706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product of complex arrays: threaded wrapper to the cblas_zdotc BLAS1 function. <br/></td></tr>
<tr class="separator:gafafc5a6d2f24e055d3b9d4e36198f706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffe4a0ee242ac993d41a38f9914dc583"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaffe4a0ee242ac993d41a38f9914dc583"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaffe4a0ee242ac993d41a38f9914dc583">eblas_ddot</a> (int N, const double *x, int incx, const double *y, int ncy)</td></tr>
<tr class="memdesc:gaffe4a0ee242ac993d41a38f9914dc583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product of real arrays: threaded wrapper to the cblas_ddot BLAS1 function. <br/></td></tr>
<tr class="separator:gaffe4a0ee242ac993d41a38f9914dc583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7605fb2b9744d4e1c7de3439cb87cd99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7605fb2b9744d4e1c7de3439cb87cd99"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga7605fb2b9744d4e1c7de3439cb87cd99">eblas_dznrm2</a> (int N, const <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:ga7605fb2b9744d4e1c7de3439cb87cd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-norm of a complex array: threaded wrapper to the cblas_dznrm2 BLAS1 function <br/></td></tr>
<tr class="separator:ga7605fb2b9744d4e1c7de3439cb87cd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga465cc13a28dd1b92df1929e386516b3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga465cc13a28dd1b92df1929e386516b3e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga465cc13a28dd1b92df1929e386516b3e">eblas_dnrm2</a> (int N, const double *x, int incx)</td></tr>
<tr class="memdesc:ga465cc13a28dd1b92df1929e386516b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-norm of a real array: threaded wrapper to the cblas_dnrm2 BLAS1 function <br/></td></tr>
<tr class="separator:ga465cc13a28dd1b92df1929e386516b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga702c12a5f0fdc02fa664c20f3fcd4a88"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga702c12a5f0fdc02fa664c20f3fcd4a88"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga702c12a5f0fdc02fa664c20f3fcd4a88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga702c12a5f0fdc02fa664c20f3fcd4a88">eblas_copy_gpu</a> (T *dest, const T *src, int N)</td></tr>
<tr class="memdesc:ga702c12a5f0fdc02fa664c20f3fcd4a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga3e6f244886dd30b195522884c18637f2" title="Copy a data array. ">eblas_copy()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga702c12a5f0fdc02fa664c20f3fcd4a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b16eac198d041a2552414dca8c6f8f1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1b16eac198d041a2552414dca8c6f8f1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1b16eac198d041a2552414dca8c6f8f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga1b16eac198d041a2552414dca8c6f8f1">eblas_zero_gpu</a> (int N, T *x)</td></tr>
<tr class="memdesc:ga1b16eac198d041a2552414dca8c6f8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga86241e74ed835c20636e5f67b22abf3b" title="Zero a data array. ">eblas_zero()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga1b16eac198d041a2552414dca8c6f8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad8f16e4ac5357add3168d9c49ac2fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacad8f16e4ac5357add3168d9c49ac2fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gacad8f16e4ac5357add3168d9c49ac2fa">eblas_zdscal_gpu</a> (int N, double a, <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:gacad8f16e4ac5357add3168d9c49ac2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga7106ac749d4593f73b27a119e9486e6d" title="Scale a complex array by a real scale factor: threaded wrapper to the cblas_zdscal BLAS1 function...">eblas_zdscal()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:gacad8f16e4ac5357add3168d9c49ac2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f8e8322bf8d0729f1499680e0dfe7cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8f8e8322bf8d0729f1499680e0dfe7cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga8f8e8322bf8d0729f1499680e0dfe7cb">eblas_zscal_gpu</a> (int N, const <a class="el" href="structcomplex.html">complex</a> &amp;a, <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:ga8f8e8322bf8d0729f1499680e0dfe7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of eblas_zscal for GPU data pointers. <br/></td></tr>
<tr class="separator:ga8f8e8322bf8d0729f1499680e0dfe7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf23131853917b31a47d7fbdd512f9a83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf23131853917b31a47d7fbdd512f9a83"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gaf23131853917b31a47d7fbdd512f9a83">eblas_zaxpy_gpu</a> (int N, const <a class="el" href="structcomplex.html">complex</a> &amp;a, const <a class="el" href="structcomplex.html">complex</a> *x, int incx, <a class="el" href="structcomplex.html">complex</a> *y, int incy)</td></tr>
<tr class="memdesc:gaf23131853917b31a47d7fbdd512f9a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga87bedbfedbae0efdb4b4c1207e36783d" title="Scaled-accumulate on complex arrays: threaded wrapper to the cblas_zaxpy BLAS1 function. ">eblas_zaxpy()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:gaf23131853917b31a47d7fbdd512f9a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278331b2acb3b0e598b4cc108c8c202e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga278331b2acb3b0e598b4cc108c8c202e"></a>
<a class="el" href="structcomplex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga278331b2acb3b0e598b4cc108c8c202e">eblas_zdotc_gpu</a> (int N, const <a class="el" href="structcomplex.html">complex</a> *x, int incx, const <a class="el" href="structcomplex.html">complex</a> *y, int incy)</td></tr>
<tr class="memdesc:ga278331b2acb3b0e598b4cc108c8c202e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#gafafc5a6d2f24e055d3b9d4e36198f706" title="Dot product of complex arrays: threaded wrapper to the cblas_zdotc BLAS1 function. ">eblas_zdotc()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:ga278331b2acb3b0e598b4cc108c8c202e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71862f9e023ce0f62601f0ea5222b81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab71862f9e023ce0f62601f0ea5222b81"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gab71862f9e023ce0f62601f0ea5222b81">eblas_dznrm2_gpu</a> (int N, const <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:gab71862f9e023ce0f62601f0ea5222b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga7605fb2b9744d4e1c7de3439cb87cd99" title="2-norm of a complex array: threaded wrapper to the cblas_dznrm2 BLAS1 function ">eblas_dznrm2()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:gab71862f9e023ce0f62601f0ea5222b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53707938a6bc21c6e01f719a3fe51f30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#ga53707938a6bc21c6e01f719a3fe51f30">eblas_capMinMax</a> (const int N, double *x, double &amp;xMin, double &amp;xMax, double capLo=-DBL_MAX, double capHi=+DBL_MAX)</td></tr>
<tr class="memdesc:ga53707938a6bc21c6e01f719a3fe51f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum and maximum of a data array and optionally cap it from above and/or below.  <a href="group__Operators.html#ga53707938a6bc21c6e01f719a3fe51f30">More...</a><br/></td></tr>
<tr class="separator:ga53707938a6bc21c6e01f719a3fe51f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae479c614697e16892fe5554f68f3882f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae479c614697e16892fe5554f68f3882f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Operators.html#gae479c614697e16892fe5554f68f3882f">eblas_capMinMax_gpu</a> (const int N, double *x, double &amp;xMin, double &amp;xMax, double capLo=-DBL_MAX, double capHi=+DBL_MAX)</td></tr>
<tr class="memdesc:gae479c614697e16892fe5554f68f3882f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="group__Operators.html#ga53707938a6bc21c6e01f719a3fe51f30" title="Find the minimum and maximum of a data array and optionally cap it from above and/or below...">eblas_capMinMax()</a> for GPU data pointers. <br/></td></tr>
<tr class="separator:gae479c614697e16892fe5554f68f3882f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Commonly used BLAS-like routines. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
    <li class="navelem"><a class="el" href="dir_4270bfced15e0e73154b13468c7c9ad9.html">core</a></li><li class="navelem"><a class="el" href="BlasExtra_8h.html">BlasExtra.h</a></li>
</div>
</body>
</html>
